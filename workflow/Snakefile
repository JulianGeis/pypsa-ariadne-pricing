# SPDX-FileCopyrightText: : 2017-2023 The PyPSA-Eur Authors
#
# SPDX-License-Identifier: MIT

from snakemake.remote.HTTP import RemoteProvider as HTTPRemoteProvider

HTTP = HTTPRemoteProvider()

configfile: "workflow/submodules/pypsa-eur/config/config.default.yaml"
configfile: "config/config.yaml"
configfile: "config/config.personal.yaml"

run = config.get("run", {})
RDIR = run["name"] + "/" if run.get("name") else ""
RESOURCES = "resources/" + RDIR if not run.get("shared_resources") else "resources/"
RESULTS = "results/" + RDIR

wildcard_constraints:
    simpl="[a-zA-Z0-9]*",
    clusters="[0-9]+(m|c)?|all",


wildcard_constraints:
    simpl="[a-zA-Z0-9]*",
    clusters="[0-9]+(m|c)?|all",

module pypsaeur:
    snakefile:
        "submodules/pypsa-eur/Snakefile"
    config:
        config


use rule * from pypsaeur


from pathlib import Path

data_dir = Path("workflow/submodules/pypsa-eur/data")
rule get_data:
    output:
        [
            str(Path("data") / p.relative_to(data_dir))
            for p in data_dir.rglob("*")
            if p.is_file()
        ],
    shell:
        """
        mkdir -p data
        cp -nR {data_dir}/. data/
        """


rule clean:
    message: "Remove all build results but keep downloaded data."
    run:
         import shutil

         shutil.rmtree("resources")
         shutil.rmtree("results")
         print("Data downloaded to data/ has not been cleaned.")


rule retrieve_ariadne_scenario_data:
    params:
        iiasa=config["iiasa_database"]
    output:
        data=RESOURCES + "ariadne_scenario_data.csv"
    log:
        "logs/retrieve_ariadne_scenario_data.log"
    resources:
        mem_mb=1000
    script:
        "scripts/retrieve_ariadne_scenario_data.py"

if config["enable"]["retrieve"] and config["enable"].get("retrieve_cost_data", True):

    use rule retrieve_cost_data from pypsaeur with:
        output:
            "data/costs_{year}-original.csv",

rule modify_cost_data:
    input:
        costs="data/costs_{year}-original.csv",
	modifications="ariadne-data/costs_{year}-modifications.csv",
    output:
       "data/costs_{year}.csv",
    resources:
        mem_mb=1000
    script:
        "scripts/modify_cost_data.py"


use rule solve_sector_network_myopic from pypsaeur with:
    params:
        **{k: v for k, v in rules.solve_sector_network_myopic.params.items() if k != "custom_extra_functionality"},
        custom_extra_functionality=workflow.source_path("scripts/additional_functionality.py"),
    input:
        **rules.solve_sector_network_myopic.input,
        co2_totals_name=RESOURCES + "co2_totals.csv",


rule modify_existing_heating:
    input:
        ariadne=RESOURCES + "ariadne_scenario_data.csv",
        existing_heating="data/existing_infrastructure/existing_heating_raw.csv",
    output:
        existing_heating=RESOURCES + "existing_heating.csv",
    resources:
        mem_mb=1000
    script:
        "scripts/modify_existing_heating.py"


use rule add_existing_baseyear from pypsaeur with:
    input:
        **{k: v for k, v in rules.add_existing_baseyear.input.items() if k != "existing_heating"},
	existing_heating=RESOURCES + "existing_heating.csv",


use rule solve_sector_network_myopic from pypsaeur with:
    params:
        **{k: v for k, v in rules.solve_sector_network_myopic.params.items() if k != "custom_extra_functionality"},
        custom_extra_functionality=workflow.source_path("scripts/additional_functionality.py"),
    input:
        **rules.solve_sector_network_myopic.input,
        co2_totals_name=RESOURCES + "co2_totals.csv",


rule modify_existing_heating:
    input:
        ariadne=RESOURCES + "ariadne_scenario_data.csv",
        existing_heating="data/existing_infrastructure/existing_heating_raw.csv",
    output:
        existing_heating=RESOURCES + "existing_heating.csv",
    resources:
        mem_mb=1000
    script:
        "scripts/modify_existing_heating.py"


use rule add_existing_baseyear from pypsaeur with:
    input:
        **{k: v for k, v in rules.add_existing_baseyear.input.items() if k != "existing_heating"},
	existing_heating=RESOURCES + "existing_heating.csv",


use rule solve_sector_network_myopic from pypsaeur with:
    params:
        **{k: v for k, v in rules.solve_sector_network_myopic.params.items() if k != "custom_extra_functionality"},
        custom_extra_functionality=workflow.source_path("scripts/additional_functionality.py"),
    input:
        **rules.solve_sector_network_myopic.input,
        co2_totals_name=RESOURCES + "co2_totals.csv",


rule modify_existing_heating:
    input:
        ariadne=RESOURCES + "ariadne_scenario_data.csv",
        existing_heating="data/existing_infrastructure/existing_heating_raw.csv",
    output:
        existing_heating=RESOURCES + "existing_heating.csv",
    resources:
        mem_mb=1000
    script:
        "scripts/modify_existing_heating.py"



use rule add_existing_baseyear from pypsaeur with:
    input:
        **{k: v for k, v in rules.add_existing_baseyear.input.items() if k != "existing_heating"},
	existing_heating=RESOURCES + "existing_heating.csv",

rule build_wasserstoff_kernnetz:
    input:
        wasserstoff_kernnetz_1=HTTP.remote(
            "https://fnb-gas.de/wp-content/uploads/2023/11/2023_11_15_Anlage2_Leitungsmeldungen_weiterer_potenzieller_Wasserstoffnetzbetreiber_Veroeffentlichung_final.xlsx",
            keep_local=True,
            static=True,
        ),
        wasserstoff_kernnetz_2=HTTP.remote(
            "https://fnb-gas.de/wp-content/uploads/2023/11/2023_11_15_Anlage3_FNB_Massnahmenliste_Veroeffentlichung_final.xlsx",
            keep_local=True,
            static=True,
        ),
        locations="data/wasserstoff_kernnetz/locations_wasserstoff_kernnetz.csv",
    output:
        cleaned_wasserstoff_kernnetz="resources/wasserstoff_kernnetz.csv",
    script:
        "scripts/build_wasserstoff_kernnetz.py"


rule cluster_wasserstoff_kernnetz:
    params: 
        divide_pipes=config["wasserstoff_kernnetz"]["divide_pipes"]
    input:
        cleaned_h2_network="resources/wasserstoff_kernnetz.csv",
        regions_onshore="resources/regions_onshore_elec_s{simpl}_{clusters}.geojson",
        regions_offshore="resources/regions_offshore_elec_s{simpl}_{clusters}.geojson",
    output:
        clustered_h2_network="resources/wasserstoff_kernnetz_elec_s{simpl}_{clusters}.csv",
    script:
        "scripts/cluster_wasserstoff_kernnetz.py"


use rule prepare_sector_network from pypsaeur with:
    input:
        **rules.prepare_sector_network.input,
        custom_h2_pipelines="resources/wasserstoff_kernnetz_elec_s{simpl}_{clusters}.csv" if config["wasserstoff_kernnetz"]["enable"] else [],